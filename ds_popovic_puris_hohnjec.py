# -*- coding: utf-8 -*-
"""kn_bezf.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X--ljJ_OcAQ8jmN6lRHIjZRTq_0DE1qY
"""

pip install deap

pip install mpi4py

import random
import numpy

from deap import algorithms
from deap import base
from deap import creator
from deap import tools
from mpi4py import MPI
from os import environ
from typing import *

MPIComm = Union[MPI.Intracomm, MPI.Intercomm]

IND_INIT_SIZE = 5
MAX_ITEM = 50
MAX_WEIGHT = 50
NBR_ITEMS = 20

random.seed(64)

items = {}

for i in range(NBR_ITEMS):
    items[i] = (random.randint(1, 10), random.uniform(0, 100))

creator.create("Fitness", base.Fitness, weights=(-1.0, 1.0))
creator.create("Individual", set, fitness=creator.Fitness)

toolbox = base.Toolbox()
toolbox.register("attr_item", random.randrange, NBR_ITEMS)

toolbox.register("individual", tools.initRepeat, creator.Individual, 
    toolbox.attr_item, IND_INIT_SIZE)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

def evalKnapsack(individual):
    weight = 0.0
    value = 0.0
    for item in individual:
        weight += items[item][0]
        value += items[item][1]
    if len(individual) > MAX_ITEM or weight > MAX_WEIGHT:
        return 10000, 0           
    return weight, value

def cxSet(ind1, ind2):
    temp = set(ind1)               
    ind1 &= ind2                   
    ind2 ^= temp                   
    return ind1, ind2
    
def mutSet(individual):
    
    if random.random() < 0.5:
        if len(individual) > 0:     
            individual.remove(random.choice(sorted(tuple(individual))))
    else:
        individual.add(random.randrange(NBR_ITEMS))
    return individual,

toolbox.register("evaluate", evalKnapsack)
toolbox.register("mate", cxSet)
toolbox.register("mutate", mutSet)
toolbox.register("select", tools.selNSGA2)

def main():
    mpi_comm = MPI.COMM_WORLD
    mpi_rank = mpi_comm.Get_rank()
    mpi_size = mpi_comm.Get_size()
    random.seed(64)
    NGEN = 50
    MU = 50
    LAMBDA = 100
    CXPB = 0.7
    MUTPB = 0.2

    if mpi_rank == 0:
       pop = toolbox.population(n=MU)
      
       mpi_comm.bcast(pop)
       print('Controller @ MPI Rank   0:  Input {}'.format(pop))
       GatherResponseType = List[Tuple[str, int]]
       response_array = mpi_comm.gather(None) 

   
       mpi_size = mpi_comm.Get_size()
       if len(response_array) != mpi_size:
        print('ERROR!  The MPI world ima {} clanova, a ovdje ih ima samo {}!'
            .format(mpi_size, len(response_array))
        )
        return 1


       for i in range(1, mpi_size):
        if len(response_array[i]) != 3:
            print('WARNING!  MPI rank {} sent a mis-sized ({}) tuple!'
                .format(
                    i,
                    len(response_array[i])
                )
            )
            continue
        if type(response_array[i][0]) is not str:
            print('WARNING!  MPI rank {} sent a tuple with a {} instead of a str!'
                .format(
                    i,
                    str(type(response_array[i][0]))
                )
            )
            continue
        if type(response_array[i][1]) is not int:
            print('WARNING!  MPI rank {} sent a tuple with a {} instead of an int!'
                .format(
                    i,
                    str(type(response_array[i][1]))
                )
            )
            continue
     

        print('   Proces  MPI Rank {: >3}: Output {} is {} (from {})'
            .format(
                i,
                response_array[i][1],
                result,
                response_array[i][0],
            )
        )
        mpi_comm.send(
            obj=0,
            dest=i,
            tag=0,
        )

       mpi_comm.barrier()
    
      
    else:
      mpi_rank = mpi_comm.Get_rank()
      pop = mpi_comm.bcast(None)
      if type(pop) is not int:
        print('ERROR in MPI rank {}: Received a non-integer "{}" from the broadcast!'
            .format(
                mpi_rank,
                pop,
            )
        )
        return 1
    
      pop = pop + mpi_rank
      response = (
        MPI.Get_processor_name(),
        pop,
    )
      mpi_comm.gather(response)

      def get_message(mpi_comm):
        
        message = mpi_comm.recv(
            source=0,
            tag=0,
        )
        if type(message) is not int:
            print('ERROR in MPI rank {}: Received a non-integer message!'
                .format(
                    mpi_rank,
                )
            )
            return None
        else:
            return message

  
      message = get_message(mpi_comm)
      while (message is not None) and (message != 0):
        
        mpi_comm.send(
            obj=int(message/2),
            dest=0,
            tag=0,
        )

        # nova poruka
        message = get_message(mpi_comm)

   
      if message is None:
        return 1
      mpi_comm.barrier()


   
    hof = tools.ParetoFront() 
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean, axis=0)
    stats.register("std", numpy.std, axis=0)
    stats.register("min", numpy.min, axis=0)
    stats.register("max", numpy.max, axis=0)
    
    algorithms.eaMuPlusLambda(pop, toolbox, MU, LAMBDA, CXPB, MUTPB, NGEN, stats,
                              halloffame=hof)
    
    return pop, stats, hof
                 
if __name__ == "__main__":
    main()